# ---
# - hosts: localhost
#   vars_files:
#     - batch_variables.yaml
#     - secret.yaml
#   gather_facts: true
#   collections:
#     - community.aws
#   vars:
#     state_store: "s3://{{ s3name }}"
#     max_deletion_attempts: 5
#     deletion_delay_seconds: 30
#     batch_size: 5
#     async_timeout: 900
#     poll_interval: 60

#   tasks:
#     - name: Set kops path for Linux
#       set_fact:
#         kops_path: "/usr/local/bin/kops"
#       when: ansible_distribution in ['Ubuntu', 'Fedora', 'CentOS', 'RedHat']

#     - name: Set kops path for macOS
#       set_fact:
#         kops_path: "/opt/homebrew/bin/kops"
#       when: ansible_distribution == 'MacOSX'

#     - name: Get list of existing clusters
#       command: "{{ kops_path }} get clusters --state={{ state_store }} -o json"
#       register: existing_clusters_output
#       ignore_errors: yes

#     - name: Parse existing clusters
#       set_fact:
#         existing_cluster_names: "{{ (existing_clusters_output.stdout | from_json | map(attribute='metadata.name') | list) if existing_clusters_output.rc == 0 else [] }}"

#     - name: Show existing clusters
#       debug:
#         msg: "Found existing clusters: {{ existing_cluster_names }}"

#     - name: Generate list of clusters to delete
#       set_fact:
#         clusters_to_delete: "{{ existing_cluster_names | select('match', '^' + cluster_name_prefix + '-' + instance_type + '-aws-\\d+\\.k8s\\.local$') | list }}"

#     - name: Show clusters to delete
#       debug:
#         msg: "Clusters identified for deletion: {{ clusters_to_delete }}"

#     - name: Initialize deletion state
#       set_fact:
#         remaining_clusters: "{{ clusters_to_delete }}"
#         successfully_deleted: []

#     - name: Launch async deletion tasks
#       command: "{{ kops_path }} delete cluster --name={{ item }} --state={{ state_store }} --wait 15m --interval 60s --yes"
#       async: "{{ async_timeout }}"
#       poll: 0
#       register: async_results
#       loop: "{{ remaining_clusters }}"
#       loop_control:
#         loop_var: item
#         label: "{{ item }}"

#     - name: Wait for cluster deletions
#       async_status:
#         jid: "{{ async_result_item.ansible_job_id }}"
#       loop: "{{ async_results.results }}"
#       loop_control:
#         loop_var: async_result_item
#         label: "{{ async_result_item.item }}"
#       register: job_results
#       until: job_results.finished | default(false)
#       retries: "{{ (async_timeout / poll_interval) | int }}"
#       delay: "{{ poll_interval }}"


#     # - name: Debug job results
#     #   debug:
#     #     var: job_results.results

#     - name: Initialize successfully deleted clusters list
#       set_fact:
#         successfully_deleted: []

#     - name: Update successfully deleted clusters
#       set_fact:
#         successfully_deleted: "{{ successfully_deleted + cluster_name if cluster_name is not none else successfully_deleted }}"
#       loop: "{{ job_results.results }}"
#       loop_control:
#         loop_var: async_result_item
#       vars:
#         cluster_name: "{{ async_result_item.stdout | regex_search('Deleted cluster: \"([^\"]+)\"', '\\1') }}"
#       when:
#         - async_result_item.stdout is defined

#     - name: Debug extracted cluster names
#       debug:
#         msg: "Cluster name extracted: {{ cluster_name }}"
#       loop: "{{ job_results.results }}"
#       loop_control:
#         loop_var: async_result_item
#       vars:
#         cluster_name: "{{ async_result_item.stdout | regex_search('Deleted cluster: \"([^\"]+)\"', '\\1') }}"

#     - name: Update remaining clusters
#       set_fact:
#         remaining_clusters: "{{ remaining_clusters | difference(successfully_deleted) }}"

#     - name: Show progress
#       debug:
#         msg: "Successfully deleted: {{ successfully_deleted }}. Remaining clusters: {{ remaining_clusters }}."

#     - name: Check for undeleted clusters
#       fail:
#         msg: "Some clusters could not be deleted: {{ remaining_clusters }}"
#       when: remaining_clusters | length > 0

#     - name: Success message
#       debug:
#         msg: "All clusters successfully deleted."
#       when: remaining_clusters | length == 0


---
- hosts: localhost
  vars_files:
    - batch_variables.yaml
    - secret.yaml
  gather_facts: true
  collections:
    - community.aws
  vars:
    state_store: "s3://{{ s3name }}"
    max_deletion_attempts: 5
    deletion_delay_seconds: 30
    batch_size: 15
    async_timeout: 900
    poll_interval: 60

  tasks:
    - name: Set kops path for Linux
      set_fact:
        kops_path: "/usr/local/bin/kops"
      when: ansible_distribution in ['Ubuntu', 'Fedora', 'CentOS', 'RedHat']

    - name: Set kops path for macOS
      set_fact:
        kops_path: "/opt/homebrew/bin/kops"
      when: ansible_distribution == 'MacOSX'

    - name: Get list of existing clusters
      command: "{{ kops_path }} get clusters --state={{ state_store }} -o json"
      register: existing_clusters_output
      ignore_errors: yes

    - name: Parse existing clusters
      set_fact:
        existing_cluster_names: "{{ (existing_clusters_output.stdout | from_json | map(attribute='metadata.name') | list) if existing_clusters_output.rc == 0 else [] }}"

    - name: Show existing clusters
      debug:
        msg: "Found existing clusters: {{ existing_cluster_names }}"

    - name: Generate list of clusters to delete
      set_fact:
        clusters_to_delete: "{{ existing_cluster_names | select('match', '^' + cluster_name_prefix + '-' + instance_type + '-aws-\\d+\\.k8s\\.local$') | list }}"

    - name: Show clusters to delete
      debug:
        msg: "Clusters identified for deletion: {{ clusters_to_delete }}"

    - name: Initialize deletion state
      set_fact:
        remaining_clusters: "{{ clusters_to_delete }}"
        successfully_deleted: []

    - name: Split clusters into batches
      set_fact:
        cluster_batches: "{{ remaining_clusters | batch(batch_size) }}"

    - name: Delete clusters in batches
      include_tasks: delete_max_batch_cluster.yaml
      loop: "{{ cluster_batches }}"
      loop_control:
        loop_var: batch